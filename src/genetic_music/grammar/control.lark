// ===========================================
// control.lark — Typed grammar for ControlPattern (domains merged)
// ===========================================
// Domain-typed routing for String-based CP constructors is integrated here.
//  • sound/s take SAMPLE domain strings
//  • vowel takes VOWEL domain strings
//  • pS/pF/pI/pN take curated PARAM names (for p*) plus typed patterns
// The rest of the CP grammar remains as in your original file.

%import .tokens (INT, DOUBLE, STRING, BOOL, SILENCE)
%import .tokens (OP_POW_BOTH, OP_POW_RIGHT, OP_POW_LEFT)
%import .tokens (OP_MUL_BOTH, OP_MUL_RIGHT, OP_MUL_LEFT)
%import .tokens (OP_DIV_BOTH, OP_DIV_RIGHT, OP_DIV_LEFT)
%import .tokens (OP_MOD_BOTH, OP_MOD_RIGHT, OP_MOD_LEFT)
%import .tokens (OP_ADD_BOTH, OP_ADD_RIGHT, OP_ADD_LEFT)
%import .tokens (OP_SUB_BOTH, OP_SUB_RIGHT, OP_SUB_LEFT)
%import .tokens (OP_HASH, OP_PIPE_R_BOTH, OP_PIPE_R, OP_R_PIPE)
%import .tokens (OP_PIPE_L_BOTH, OP_PIPE_L, OP_L_PIPE)
%import .tokens (OP_MONOID, OP_SHIFT_L, OP_SHIFT_R)

%import .pattern_time   (pattern_time,  transform_time,  time_arg, time_scalar)
%import .pattern_int    (pattern_int,   transform_int)
%import .pattern_double (pattern_double,transform_double)
%import .pattern_string (pattern_string,transform_string)
%import .pattern_note   (pattern_note,  transform_note)
%import .pattern_bool   (pattern_bool,  transform_bool)

// --- Domain-specialized string patterns ---
%import .pattern_string_sample (pattern_sample_string, transform_sample_string)
%import .pattern_string_vowel  (pattern_vowel_string,  transform_vowel_string)
%import .string_domains        (PARAM_STRING)

param_name: PARAM_STRING

// ---------------------------------------------------------------------------
// Expression shape (playable by construction)
// ---------------------------------------------------------------------------
// We distinguish between:
//   - cp_sound_atom    : syntactic heads that *introduce* audio (samples/notes)
//   - cp_playable_term : CP subtrees guaranteed to contain at least one sound
//   - cp_control_only  : CP subtrees that may be pure control (no sound)
//
// The public nonterminal ``control_pattern`` is *always playable*.
// Any production which could yield a CP without sound lives under
// ``cp_control_only`` and is never exposed as ``control_pattern`` on its own.

// Single-tier, left-associative CP infix layer: union/pipe/monoid and numeric merges.
?control_pattern: cp_playable_term (cp_infix_op cp_playable_term)*

cp_infix_op: OP_HASH
           | OP_PIPE_R_BOTH | OP_PIPE_R | OP_R_PIPE
           | OP_PIPE_L_BOTH | OP_PIPE_L | OP_L_PIPE
           | OP_MONOID
           | OP_MUL_BOTH | OP_MUL_RIGHT | OP_MUL_LEFT
           | OP_DIV_BOTH | OP_DIV_RIGHT | OP_DIV_LEFT
           | OP_MOD_BOTH | OP_MOD_RIGHT | OP_MOD_LEFT
           | OP_ADD_BOTH | OP_ADD_RIGHT | OP_ADD_LEFT
           | OP_SUB_BOTH | OP_SUB_RIGHT | OP_SUB_LEFT

// Internal union of playable vs control-only CPs
?cp_any: cp_playable_term | cp_control_only

// ---------- Playable terms ----------
// Any derivation of ``cp_playable_term`` must include at least one ``cp_sound_atom``.
?cp_playable_term: "(" control_pattern ")"                 // grouping keeps playability
                 | prefix_cp "(" cp_playable_term ")"      // safe prefix transforms
                 | cp_sound_atom                           // direct constructors with sound
                 | cp_note_atom 
                 // Named binary combinators: both sides must be playable to avoid
                 // musically-empty overlays.
                 // This keeps the whole expression playable and ensures every overlay
                 // actually combines two sound-bearing patterns.
                 | cp_binary_named "(" cp_playable_term ")" "(" cp_playable_term ")"
                 // Higher-order appliers: body must be playable
                 | cp_applied_playable
                 | cp_jux_playable
                 | cp_slice_playable
                 | cp_chop_playable
                 | cp_mask_playable
                 | cp_striate_playable
                 | cp_euclid_playable
                 | cp_timeops_playable
                 | cp_lists_playable

// Note-producing constructors (introduce pitch information)
cp_note_atom: note_to_cp "(" pattern_note ")"
            | note_to_cp STRING 

// ---------- Control-only terms ----------
// These can be pure-control (no sound) and only appear as children of playable forms.
?cp_control_only: "(" cp_control_only ")"                  // grouping
                | prefix_cp "(" cp_control_only ")"        // prefix transforms
                | cp_control_constructor                   // non-audio constructors
                | cp_binary_named "(" cp_control_only ")" "(" cp_control_only ")"
                | cp_applied_control
                | cp_jux_control
                | cp_slice_control
                | cp_chop_control
                | cp_mask_control
                | cp_striate_control
                | cp_euclid_control
                | cp_timeops_control
                | cp_lists_control

// ---------- Constructors from typed patterns ----------
// NOTE: We inline domain-typed string constructors here instead of using a
// separate head rule (string_to_cp), so that each head can take its own
// argument shape without ambiguity.

// Audio-producing constructors (introduce sound)
// Only 's' and 'sound' are true sound sources. 'vowel' is a filter effect, not a source.
cp_sound_atom: ("s"     "(" pattern_sample_string ")") // String → CP (domain-typed)
    | ("sound" "(" pattern_sample_string ")")

// Pure-control constructors (no direct audio)
cp_control_constructor: ("pS"    param_name "(" pattern_string ")")
      // Named-parameter setters (domain-typed names)
    | ("pF"    param_name "(" pattern_double ")")
    | ("pN"    param_name "(" pattern_note ")")
    | ("pI"    param_name "(" pattern_int ")")
                      // Demoted to control-only (effects/filters, not sources)
                      | ("vowel" "(" pattern_vowel_string ")")
                      | (double_to_cp   "(" pattern_double ")")
                      | (int_to_cp      "(" pattern_int ")")

// A conservative but fairly complete Double→CP menu
double_to_cp: "speed" | "pan" | "gain" | "shape" | "cutoff" | "crush"
            | "nudge" | "overgain" | "overshape" | "accelerate"
            | "bandf" | "bandq" | "begin" | "end" | "loop" | "legato"
            | "delay" | "delaytime" | "delayfeedback"
            | "hcutoff" | "hresonance" | "resonance" | "coarse"

note_to_cp:   "n" | "note" | "up"
int_to_cp:   "cut"

// ---------- Named binary CP combinators ----------
cp_binary_named: "overlay" | "append" | "slowAppend" | "slowappend"
               | "fastAppend" | "fastappend" | "interlace"

// ---------- Higher-order CP appliers ----------
// Playable variants require a playable body; control variants can be pure control.
// NOTE: Only deterministic functions are included. Random functions (sometimes, often, rarely,
// almostNever, almostAlways, sometimesBy, someCycles, someCyclesBy) have been removed.
?cp_applied_playable: "never"       transform_cp "(" cp_playable_term ")"
                    | "always"      transform_cp "(" cp_playable_term ")"
                    | "superimpose" transform_cp "(" cp_playable_term ")"
                    // First Pattern Int/Time arguments must be grouped for Haskell application
                    | "every"        "(" pattern_int  ")"  transform_cp "(" cp_playable_term ")"
                    | "off"          "(" pattern_time ")"  transform_cp "(" cp_playable_term ")"
                    | "inside"       "(" pattern_time ")"  transform_cp "(" cp_playable_term ")"
                    | "outside"      "(" pattern_time ")"  transform_cp "(" cp_playable_term ")"
                    | "within"       "(" time_arg "," time_arg ")" transform_cp "(" cp_playable_term ")"
                    | "whenmod"      "(" pattern_time ")" "(" pattern_time ")" transform_cp "(" cp_playable_term ")"
                    | "plyWith"      "(" pattern_time ")"  transform_cp "(" cp_playable_term ")"
                    | "chunk"        "(" pattern_int  ")"  transform_cp "(" cp_playable_term ")"
                    | "chunk'"       "(" pattern_int  ")" "(" pattern_int ")" transform_cp "(" cp_playable_term ")"

?cp_applied_control: "never"       transform_cp "(" cp_control_only ")"
                   | "always"      transform_cp "(" cp_control_only ")"
                   | "superimpose" transform_cp "(" cp_control_only ")"
                   | "every"        "(" pattern_int    ")" transform_cp "(" cp_control_only ")"
                   | "off"          "(" pattern_time   ")" transform_cp "(" cp_control_only ")"
                   | "inside"       "(" pattern_time   ")" transform_cp "(" cp_control_only ")"
                   | "outside"      "(" pattern_time   ")" transform_cp "(" cp_control_only ")"
                   | "within"       "(" time_arg "," time_arg ")" transform_cp "(" cp_control_only ")"
                   | "whenmod"      "(" pattern_time ")" "(" pattern_time ")" transform_cp "(" cp_control_only ")"
                   | "plyWith"      "(" pattern_time ")" transform_cp "(" cp_control_only ")"
                   | "chunk"        "(" pattern_int  ")" transform_cp "(" cp_control_only ")"
                   | "chunk'"       "(" pattern_int  ")" "(" pattern_int ")" transform_cp "(" cp_control_only ")"

// ---------- Jux family ----------
?cp_jux_playable: "jux"     transform_cp "(" cp_playable_term ")"
                | "juxcut"  transform_cp "(" cp_playable_term ")"
                | "jux4"    transform_cp "(" cp_playable_term ")"
                | "jux'"    transform_cp_list "(" cp_playable_term ")"
                | "juxcut'" transform_cp_list "(" cp_playable_term ")"
                | "juxBy"   "(" pattern_double ")" transform_cp "(" cp_playable_term ")"

?cp_jux_control: "jux"     transform_cp "(" cp_control_only ")"
               | "juxcut"  transform_cp "(" cp_control_only ")"
               | "jux4"    transform_cp "(" cp_control_only ")"
               | "jux'"    transform_cp_list "(" cp_control_only ")"
               | "juxcut'" transform_cp_list "(" cp_control_only ")"
               | "juxBy"   "(" pattern_double ")" transform_cp "(" cp_control_only ")"

transform_cp_list: "[" [transform_cp ("," transform_cp)*] "]"

// ---------- Rhythmic slicers ----------
cp_slice_playable: ("slice" | "splice" | "chew" | "bite") "(" pattern_int ")" "(" pattern_int ")" "(" cp_playable_term ")"
cp_slice_control:  ("slice" | "splice" | "chew" | "bite") "(" pattern_int ")" "(" pattern_int ")" "(" cp_control_only ")"

cp_chop_playable:  ("chop" | "gap" | "spin") "(" pattern_int ")" "(" cp_playable_term ")"
cp_chop_control:   ("chop" | "gap" | "spin") "(" pattern_int ")" "(" cp_control_only ")"

// ---------- Mask / struct ----------
cp_mask_playable: ("mask" | "struct" | "substruct") "(" pattern_bool ")" "(" cp_playable_term ")"
cp_mask_control:  ("mask" | "struct" | "substruct") "(" pattern_bool ")" "(" cp_control_only ")"

// ---------- Striate / Euclid ----------
cp_striate_playable: ("striate"   "(" pattern_int ")" "(" cp_playable_term ")")
                   | ("striate'"  "(" pattern_int ")" "(" pattern_int ")" "(" cp_playable_term ")")
                   | ("striateBy" "(" pattern_int ")" "(" pattern_double ")" "(" cp_playable_term ")")

cp_striate_control: ("striate"   "(" pattern_int ")" "(" cp_control_only ")")
                  | ("striate'"  "(" pattern_int ")" "(" pattern_int ")" "(" cp_control_only ")")
                  | ("striateBy" "(" pattern_int ")" "(" pattern_double ")" "(" cp_control_only ")")

cp_euclid_playable: ("euclid"     "(" pattern_int ")" "(" pattern_int ")" "(" cp_playable_term ")")
                   | ("euclidInv" "(" pattern_int ")" "(" pattern_int ")" "(" cp_playable_term ")")
                   | ("euclidFull" "(" pattern_int ")" "(" pattern_int ")" "(" cp_playable_term ")" "(" cp_any ")")
                   | ("euclidFull" "(" pattern_int ")" "(" pattern_int ")" "(" cp_any ")" "(" cp_playable_term ")")

cp_euclid_control: ("euclid"     "(" pattern_int ")" "(" pattern_int ")" "(" cp_control_only ")")
                  | ("euclidInv" "(" pattern_int ")" "(" pattern_int ")" "(" cp_control_only ")")
                  | ("euclidFull" "(" pattern_int ")" "(" pattern_int ")" "(" cp_control_only ")" "(" cp_control_only ")")

// ---------- Time operations on CP ----------
cp_timeops_playable: ("hurry"    "(" pattern_time ")" "(" cp_playable_term ")")
                   | ("loopAt"   "(" pattern_time ")" "(" cp_playable_term ")")
                   | ("rolledBy" "(" pattern_time ")" "(" cp_playable_term ")")

cp_timeops_control: ("hurry"    "(" pattern_time ")" "(" cp_control_only ")")
                  | ("loopAt"   "(" pattern_time ")" "(" cp_control_only ")")
                  | ("rolledBy" "(" pattern_time ")" "(" cp_control_only ")")

// ---------- Lists of CP and list-based combinators (deterministic only) ----------
// Playable lists: first element must be playable, so list as a whole contains sound.
cp_list_playable: "[" cp_playable_term ("," cp_any)* "]"
cp_lists_playable: ("stack" | "cat" | "fastcat" | "fastCat" | "slowcat" | "slowCat") cp_list_playable

// Control-only lists: all elements are control_only; these never become a full control_pattern.
cp_list_control: "[" cp_control_only ("," cp_control_only)* "]"
cp_lists_control: ("stack" | "cat" | "fastcat" | "fastCat" | "slowcat" | "slowCat") cp_list_control

// ---------- Prefix transforms (ControlPattern -> ControlPattern) ----------
// NOTE: Random functions (degrade, ghost) have been removed for deterministic patterns.
?prefix_cp: "rev"
          | "brak"
          | "palindrome"
          | "fast" time_arg
          | "slow" time_arg
          | "fastGap" time_arg
          | "density" time_arg
          | "trunc" time_arg
          | "densityGap" time_arg
          | "sparsity" time_arg
          | "linger" time_arg
          | "segment" time_arg
          | "discretise" time_arg
          | "timeLoop" time_scalar
          | "swing" time_arg
          | "rotL" time_scalar
          | "rotR" time_scalar
          | "rot" INT
          | "ply" time_arg
          | OP_SHIFT_L time_arg
          | OP_SHIFT_R time_arg
          | "compress"   "(" time_arg "," time_arg ")"
          | "compressTo" "(" time_arg "," time_arg ")"
          | "zoom"       "(" time_arg "," time_arg ")"
          | "playFor" time_arg
          | "iter"    pattern_int
          | "shuffle" pattern_int
          | "scramble" pattern_int

// ---------- Transform values (ControlPattern -> ControlPattern) ----------
// NOTE: Random functions (degrade, ghost) have been removed for deterministic patterns.
?transform_cp: "rev"
             | "brak"
             | "palindrome"
             | "fast" time_arg
             | "slow" time_arg
             | "fastGap" time_arg
             | "density" time_arg
             | "trunc" time_arg
             | "densityGap" time_arg
             | "sparsity" time_arg
             | "linger" time_arg
             | "segment" time_arg
             | "discretise" time_arg
             | "timeLoop" time_scalar
             | "swing" time_arg
             | "rotL" time_scalar
             | "rotR" time_scalar
             | "rot" INT
             | "ply" time_arg
             | OP_SHIFT_L time_arg
             | OP_SHIFT_R time_arg
             | "compress"   "(" time_arg "," time_arg ")"
             | "compressTo" "(" time_arg "," time_arg ")"
             | "zoom"       "(" time_arg "," time_arg ")"
             | "playFor" time_arg
             | "iter"    pattern_int
             | "shuffle" pattern_int
             | "scramble" pattern_int
