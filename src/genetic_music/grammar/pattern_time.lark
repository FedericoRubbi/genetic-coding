// ===========================================
// pattern_time.lark â€” Typed grammar for Pattern Time
// ===========================================
// Imports only terminals & operators from common.lark.
// This module defines:
//   - pattern_time (expression)
//   - transform_time  (a value of type Pattern Time -> Pattern Time)
//   - time lists and timeCat/timecat families
// No %ignore here (handled in common.lark).

%import .tokens (INT, DOUBLE, BOOL, STRING, SILENCE)
%import .tokens (OP_POW_BOTH, OP_POW_RIGHT, OP_POW_LEFT)
%import .tokens (OP_MUL_BOTH, OP_MUL_RIGHT, OP_MUL_LEFT)
%import .tokens (OP_DIV_BOTH, OP_DIV_RIGHT, OP_DIV_LEFT)
%import .tokens (OP_MOD_BOTH, OP_MOD_RIGHT, OP_MOD_LEFT)
%import .tokens (OP_ADD_BOTH, OP_ADD_RIGHT, OP_ADD_LEFT)
%import .tokens (OP_SUB_BOTH, OP_SUB_RIGHT, OP_SUB_LEFT)
%import .tokens (OP_HASH, OP_PIPE_R_BOTH, OP_PIPE_R, OP_R_PIPE)
%import .tokens (OP_PIPE_L_BOTH, OP_PIPE_L, OP_L_PIPE)
%import .tokens (OP_MONOID, OP_SHIFT_L, OP_SHIFT_R)

// ---------- Expression shape ----------
// Single-tier, left-associative infix operators (numeric & real ops only for Time)
?pattern_time: pattern_time_term (time_infix_op pattern_time_term)*

time_infix_op: OP_MUL_BOTH | OP_MUL_RIGHT | OP_MUL_LEFT
             | OP_DIV_BOTH | OP_DIV_RIGHT | OP_DIV_LEFT
             | OP_ADD_BOTH | OP_ADD_RIGHT | OP_ADD_LEFT
             | OP_SUB_BOTH | OP_SUB_RIGHT | OP_SUB_LEFT
             | OP_MOD_BOTH | OP_MOD_RIGHT | OP_MOD_LEFT

?pattern_time_term: prefix_time "(" pattern_time ")"   // prefix transforms
                  | "(" pattern_time ")"          // grouping
                  | time_constructor                // literals / lists / families

// ---------- Constructors / literals ----------
?time_constructor: time_literal
                 | time_list_to_pat
                 | time_cat

// Basic literals allowed for Pattern Time (conservative set)
// Note: we accept numeric literals directly plus silence.
time_literal: INT
            | DOUBLE
            | SILENCE

// ---------- Lists and list-based combinators ----------
// A typed list of Pattern Time expressions (elements may themselves be expressions)
 time_list: "[" [pattern_time ("," pattern_time)*] "]"

// Constructors from a list to a Pattern Time (deterministic only)
 !time_list_to_pat: ("listToPat" | "stack" | "cat"
                  | "fastcat" | "fastCat"
                  | "slowcat" | "slowCat") time_list

// ---------- timeCat/timecat: list of (Time, Pattern Time) pairs ----------
 time_pair: "(" pattern_time "," pattern_time ")"
 time_pair_list: time_pair ("," time_pair)*
 !time_cat: ("timeCat" | "timecat") "[" time_pair_list "]"

// ---------- Prefix transforms (Pattern Time -> Pattern Time) ----------
// Keep this list self-contained (no cross-sort references). When a transform
// requires a parameter of type Time, we accept a Time argument formed by
// INT/DOUBLE or a grouped pattern_time. When a transform wants Int counts,
// we conservatively accept INT.
!prefix_time: "rev"
            | "brak"
            | "palindrome"
            | "fast" time_arg
            | "slow" time_arg
            | "fastGap" time_arg
            | "density" time_arg
            | "trunc" time_arg
            | "densityGap" time_arg
            | "sparsity" time_arg
            | "linger" time_arg
            | "segment" time_arg
            | "discretise" time_arg
            | "timeLoop" time_scalar
            | "swing" time_arg
            | "rot" INT                      // rot k
            | "rotL" time_scalar
            | "rotR" time_scalar
            | "ply" time_arg
            | OP_SHIFT_L time_arg             // <~ t  (left shift)
            | OP_SHIFT_R time_arg             // ~> t  (right shift)
            | "compress" "(" time_arg "," time_arg ")"
            | "compressTo" "(" time_arg "," time_arg ")"
            | "zoom" "(" time_arg "," time_arg ")"
            | "playFor" time_arg

// ---------- Transform values (for higher-order uses) ----------
// A transform_time denotes a function value of type
//   (Pattern Time -> Pattern Time)
// It mirrors the prefix_time repertoire but WITHOUT the subject term.
!transform_time: "rev"
               | "brak"
               | "palindrome"
               | "fast" time_arg
               | "slow" time_arg
               | "fastGap" time_arg
               | "density" time_arg
               | "trunc" time_arg
               | "densityGap" time_arg
               | "sparsity" time_arg
               | "linger" time_arg
               | "segment" time_arg
               | "discretise" time_arg
               | "timeLoop" time_scalar
               | "swing" time_arg
               | "rot" INT
               | "rotL" time_scalar
               | "rotR" time_scalar
               | "ply" time_arg
               | OP_SHIFT_L time_arg
               | OP_SHIFT_R time_arg
               | "compress" "(" time_arg "," time_arg ")"
               | "compressTo" "(" time_arg "," time_arg ")"
               | "zoom" "(" time_arg "," time_arg ")"
               | "playFor" time_arg

// Time-typed argument: either a numeric literal or a grouped time expression.
// Scalar-only Time (for transforms that require a plain Time, not a Pattern)
?time_scalar: INT
            | DOUBLE

// Pattern-time argument (allows modulation)
?time_arg: INT
         | DOUBLE
         | "(" pattern_time ")"
